[
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "08c9825a-08c3-4d43-9c31-e08fe19a793f",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC001-Install & Setup happy path: uv sync and Playwright Chromium install succeed",
    "description": "Verifies the user can follow the install steps and see a visible success/ready indication at the end.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the site root '/' (http://localhost:3000/) as the test step requires an explicit navigate action.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=UI Dataset Builder').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Run uv sync').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=playwright install chromium').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Chromium').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=environment ready').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Page title does not contain the text 'UI Dataset Builder'.\n- Text 'Run uv sync' not found on the root page.\n- Text 'playwright install chromium' not found on the root page.\n- Text 'Chromium' not found on the root page.\n- Text 'environment ready' not found on the root page.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632831256233//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.655Z",
    "modified": "2026-02-21T00:13:51.373Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "883851fd-6308-45c7-9bbb-e776e294140c",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC002-Install & Setup documentation is discoverable from the Landing page CTA",
    "description": "Verifies the landing page provides a clear call-to-action that leads the user toward install/setup guidance.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the root page '/' and look for a 'Get Started' call-to-action on the landing page.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Get Started' call-to-action (index 129) to navigate to setup/install guidance.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/nav/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the site logo 'AIDog' (index 258) to navigate back to the landing page so the 'Get Started' CTA can be tested again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the root '/' to return to the landing page so the 'Get Started' CTA can be tested again (then verify 'Get Started' is visible and click it).\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Get Started' CTA (index 416) to attempt to navigate to the setup/install guidance and then re-evaluate the URL and page content.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/nav/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Get Started').first).to_be_visible(timeout=3000)\n        assert '/setup' in frame.url\n        await expect(frame.locator('text=Install').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=uv sync').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Get Started CTA did not navigate to a page whose URL contains 'setup' after multiple click attempts.\n- Landing page remained at 'http://localhost:3000/' with landing content visible after clicking the CTA.\n- No visible page content containing the word 'Install' was found after clicking the CTA.\n- No visible page content containing the text 'uv sync' was found after clicking the CTA.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632933974211//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.663Z",
    "modified": "2026-02-21T00:15:34.105Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "1267c4a6-d327-4f2d-a5f2-586f1da38fc9",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC003-Install & Setup: error path messaging for uv sync dependency resolution failure is visible",
    "description": "Verifies the UI includes visible guidance for when uv sync fails, including missing system packages and suggested fixes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the Email and Password fields and click the Sign In button to log in (use example@gmail.com / password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email and Password fields with example@gmail.com / password123 and click the Sign In button to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the site root ('/') to follow the provided explicit step and check whether the app routes to an authenticated area or shows setup/install instructions.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Dependency resolution fails').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=missing system packages').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=suggested fixes').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=uv sync').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Required guidance text 'Dependency resolution fails' not found on site root install/setup section.\n- Required guidance text 'missing system packages' not found on site root install/setup section.\n- Required guidance text 'suggested fixes' not found on site root install/setup section.\n- Required guidance text 'uv sync' not found on site root install/setup section.\n- Incidents flow could not be inspected because authentication/incident access was not established (login attempts exhausted).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632953335389//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.670Z",
    "modified": "2026-02-21T00:15:53.708Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "674fd232-cdea-48a1-bde9-d5dfb00bac9d",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC004-Install & Setup: Playwright Chromium install step is explicitly called out",
    "description": "Verifies the setup guidance clearly specifies installing Chromium via Playwright as a required step.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'AIDog' home link (element index 49) to navigate to the root (/) so the install/setup instructions can be located.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'AIDog' home link (element index 85) to navigate to the root (/) so the install/setup instructions can be located.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the AIDog home link (element index 85) to navigate to the root (/) and locate the install/setup instructions section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Gather visible texts from the known page elements using the exact xpaths provided\n        try:\n            t1 = (await frame.locator('xpath=/html/body/div/section[1]/div[3]/a[1]').inner_text()).strip()\n        except Exception:\n            t1 = \"\"\n        try:\n            t2 = (await frame.locator('xpath=/html/body/div/section[1]/div[3]/svg').inner_text()).strip()\n        except Exception:\n            t2 = \"\"\n        try:\n            t3 = (await frame.locator('xpath=/html/body/div/section[1]/div[3]/a[2]').inner_text()).strip()\n        except Exception:\n            t3 = \"\"\n        try:\n            t4 = (await frame.locator('xpath=/html/body/div/section[2]/div[2]/div/div[1]/div[1]').inner_text()).strip()\n        except Exception:\n            t4 = \"\"\n        try:\n            t5 = (await frame.locator('xpath=/html/body/div/section[2]/div[2]/div/div[2]/div[1]').inner_text()).strip()\n        except Exception:\n            t5 = \"\"\n        try:\n            t6 = (await frame.locator('xpath=/html/body/div/section[2]/div[2]/div/div[3]/div[1]').inner_text()).strip()\n        except Exception:\n            t6 = \"\"\n        try:\n            t7 = (await frame.locator('xpath=/html/body/div/section[3]/div/a').inner_text()).strip()\n        except Exception:\n            t7 = \"\"\n        \n        # Combine all gathered text and normalize for searching\n        all_text = \"\\n\".join([t1, t2, t3, t4, t5, t6, t7]).lower()\n        \n        # Required phrases to verify according to the test plan\n        required_1 = \"playwright install chromium\"\n        required_2 = \"chromium binary\"\n        required_3 = \"installed\"\n        \n        # If the required setup guidance is not present on this page, report the issue (fail the assertions)\n        assert required_1 in all_text, \"Required setup instruction missing: 'playwright install chromium' not found on page\"\n        assert required_2 in all_text, \"Required setup instruction missing: 'Chromium binary' not found on page\"\n        assert required_3 in all_text, \"Required setup instruction missing: 'installed' not found on page\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/177163286719347//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.677Z",
    "modified": "2026-02-21T00:14:27.308Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "a4d45b22-ed21-4893-8b37-356e8fa4b4c2",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC005-Install & Setup: prerequisites mention for system packages is present",
    "description": "Verifies the setup guidance contains a visible prerequisites/system dependencies section to prevent install failures.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the AIDog home link (index 51) to navigate to the root / page as the first step toward finding the setup/install instructions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Prerequisites').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=system packages').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Linux').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=macOS').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Prerequisites heading not found on the website's root page.\n- Install/setup instructions section not present on the root page after scrolling and searching.\n- Text 'system packages' not present on the site.\n- Text 'Linux' not present on the site.\n- Text 'macOS' not present on the site.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632820113208//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.683Z",
    "modified": "2026-02-21T00:13:40.244Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "ff546ad3-dbde-438a-94c6-b847fa62c92e",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC006-Install & Setup: instructions include a clear sequence from clone to ready state",
    "description": "Verifies the install steps appear in a clear, ordered sequence matching the intended workflow.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the AIDog logo/link (index 58) to navigate to the site root ('/'), then scroll to find the install/setup instructions section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the AIDog link (index 58) to navigate to the site root ('/'); after the page changes, scroll to locate the install/setup instructions section and verify the listed texts in order.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Clone').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=uv sync').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=playwright install chromium').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=ready').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Install/setup instructions section not found on the homepage at '/'.\n- Text 'Clone' not found on the page.\n- Text 'uv sync' not found on the page.\n- Text 'playwright install chromium' not found on the page.\n- Text 'ready' not found on the page.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632839072567//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.690Z",
    "modified": "2026-02-21T00:13:59.196Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "677fb1a9-41da-458e-9828-ca07bd8a4786",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC007-Build workflow guidance is discoverable from the Landing page",
    "description": "Verifies a user can find guidance/CTA from the landing page relevant to running the Build (crawl + annotate) workflow.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the site root '/' (http://localhost:3000/) and load the landing page so the checks can be performed.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'See How It Works' link (interactive element index 207) to reveal/scroll to the How it works section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/section[1]/div[3]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=UI Dataset').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=How it works').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=build').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=dataset').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632803829073//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.697Z",
    "modified": "2026-02-21T00:13:23.987Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "ccc524ac-1b4f-4582-9d6c-026e05c8f419",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC008-Build run prerequisites are understandable from UI copy (no CLI execution)",
    "description": "Verifies the UI provides visible textual guidance that implies required inputs/outputs for the Build (URLs list, output folder, images/annotations).",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to '/' (http://localhost:3000/) to locate the main content describing the tool workflow and then scroll to find the guidance text.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=URLs').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=screenshots').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=annotations').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=COCO').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Text 'URLs' not found on the landing page under the main workflow or elsewhere\n- Text 'screenshots' not found on the landing page under the main workflow or elsewhere\n- Text 'annotations' not found on the landing page under the main workflow or elsewhere\n- Text 'COCO' not found on the landing page under the main workflow or elsewhere",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632808310679//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.704Z",
    "modified": "2026-02-21T00:13:28.499Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "ed52934b-4660-408f-a5f3-7828e89ed990",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC009-Configure crawl options with valid flags and verify run summary reflects settings",
    "description": "Verifies a user can set viewport, concurrency, scroll steps, and wait strategy and see those settings reflected in the build run output/summary.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click the Sign In button to authenticate (input into index 20 and 21, then click index 22).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email (index 90) and password (index 94) with the test credentials and click Sign In (index 98). After login, verify navigation to the app (e.g., /home) and then continue to incidents flow.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Email (index 198) with 'example@gmail.com', fill Password (index 199) with 'password123', then click Sign In (index 200). After clicking, wait for navigation and verify authentication success (URL change /presence of dashboard elements).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 289) and password (index 290) with test credentials, click Sign In (index 291), then wait for navigation and verify authentication success (URL contains \"/home\").\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to '/' (http://localhost:3000/) as the test step explicitly requires using a direct navigation to the root path.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=UI Dataset Builder').first).to_be_visible(timeout=3000)\n        assert '/login' in frame.url\n        assert '/home' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Text 'UI Dataset Builder' not found on the homepage; landing page shows AIDog hero content instead.\n- Required 'UI Dataset Builder' feature/page is missing, so viewport/concurrency/scroll/wait strategy settings cannot be verified in a build run output/summary.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771633030880911//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.710Z",
    "modified": "2026-02-21T00:17:11.152Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "c0249e01-0396-43f5-a996-e8d76a79e244",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC010-Invalid viewport flag shows validation error and prevents run",
    "description": "Verifies the CLI rejects an invalid viewport value and shows a clear validation error without proceeding.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form: input email into element [34], input password into element [35], then click the Sign In button [36].\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email into input [158], fill password into input [159], click the Sign In button [160]. After clicking, wait for the app to transition and then verify the URL contains '/home' and that the text 'invalid viewport format' is visible.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to http://localhost:3000/, click the Login link (element [287]) if present, fill the login form (email [256], password [257]), click Sign In (element [258]), wait for navigation, then check that the URL contains '/home' and search the page for the text 'invalid viewport format'.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        # -> Click the 'Login' link on the homepage (element [355]) to open the login form so the login flow can be completed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/nav/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=invalid viewport format').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login link clicked but login form did not open; no email, password, or Sign In interactive elements found on the current page.\n- Required login inputs (email, password) or Sign In button not present to perform authentication.\n- Cannot reach authenticated area ('/home') to verify the presence of the validation message 'invalid viewport format'.\n- No clickable element index for the 'Login' control is available on the homepage, preventing continuation of the login flow.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632970771176//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.716Z",
    "modified": "2026-02-21T00:16:10.892Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "1513354a-b9d2-4f9b-ab50-b5fd9885db15",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC011-Crawl run shows evidence of extra scroll screenshots setting",
    "description": "Verifies that when scroll steps are configured, the UI shows additional captured screenshots/evidence corresponding to extra scroll captures.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields with test credentials and click 'Sign In' to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'Sign In' using the visible input elements on the login page (indices [90], [94], then click [98]).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password using the visible inputs (indices [190], [191]) and click the Sign In button (index [192]) to attempt login, then wait for redirect.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to '/' (http://localhost:3000/) as the next immediate action per the test steps.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Login link on the landing page to open the login form (click element index 386).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/nav/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Login' link (element [386]) to open the login form so the email/password inputs become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/nav/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password on the login page and click 'Sign In' using the visible inputs (indices [559], [563]) and the Sign In button (index [564]) to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email input (index 630) with 'example@gmail.com', fill the password input (index 631) with 'password123', then click the Sign In button (index 632) to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password on the login page and click 'Sign In' using the visible inputs (indices 731, 732) and the Sign In button (index 733). If login redirects to /home, proceed to Incidents; otherwise report the issue.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        assert '/incidents' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login did not complete - application remained on '/login' after multiple sign-in attempts and the UI showed a persistent 'Signing in...' state.\n- Authenticated '/home' page was not reached after submitting valid test credentials; URL did not change to contain '/home'.\n- Incidents page could not be accessed because authentication failed, so verification of scroll-capture evidence/screenshots cannot be performed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771633189594062//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.723Z",
    "modified": "2026-02-21T00:19:49.720Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "901cdb84-3141-452d-b04c-c52eb42df069",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC012-Configured concurrency is displayed in the run configuration details",
    "description": "Verifies the selected concurrency value is visible in the run configuration details or settings summary after a build is initiated.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the Email and Password fields and click 'Sign In', then wait for the page to load so the post-login assertions can be checked.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email (index 122) and Password (index 123) fields again with the test credentials and click the Sign In button (index 124).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=Concurrency').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login did not complete after two sign-in attempts: the application remained on the login page showing the sign-in form.\n- Current URL is '/login' and no redirect to '/home' occurred after the sign-in attempts.\n- Credentials were entered and the Sign In button was clicked twice, but no navigation to dashboard/incidents was observed.\n- Unable to verify the 'Concurrency' value because post-login pages (home/incidents/run configuration) could not be reached.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632904065007//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.729Z",
    "modified": "2026-02-21T00:15:04.207Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "5149ac99-03e4-4c1d-9000-5f2a88b9d43d",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC013-Configured viewport is displayed and reflected in capture metadata",
    "description": "Verifies the viewport setting is visible in capture configuration/metadata and matches the configured value format (e.g., 1280x720).",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with example@gmail.com (index 20), then fill the password field with password123 (index 21), then click the Sign In button (index 22). After that, check for /home in URL and look for the text '1280x720'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 92) with example@gmail.com, fill the password (index 96) with password123, then click Sign In (index 100). After that, check for redirect to '/home' and look for text '1280x720'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=1280x720').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed - application remained on the login page after two sign-in attempts and did not redirect to /home.\n- Dashboard '/home' not reachable - URL does not contain '/home' and authenticated pages were not accessible.\n- Viewport setting '1280x720' could not be verified because authentication was not achieved and the capture configuration/metadata pages were not accessible.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632833921845//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.736Z",
    "modified": "2026-02-21T00:13:54.044Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "9afca319-95a7-4385-b3d3-0d1c73ab4939",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC014-Wait strategy networkidle is shown in crawl/run settings",
    "description": "Verifies that selecting the page load wait strategy (networkidle) is reflected in the visible run configuration.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the root path '/' of the site so the login flow can be triggered from the homepage.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Login' link to open the login form (element index 198).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/nav/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Login' link (element [198]) again to open the login form so email/password fields become visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/nav/div/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field with example@gmail.com, fill the password field with password123, then click 'Sign In'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and submit the login form (input indices 431 and 432, then click index 433) to trigger navigation; after submit, wait for the app to navigate and then verify '/home' and presence of 'networkidle'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=networkidle').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Current URL remains on the login page (contains '/login') after sign-in attempts.\n- The application shows 'Signing in...' with Email and Password inputs still visible, indicating authentication did not complete.\n- The application did not navigate to '/home' after submission, so the run configuration or incident pages were not reached.\n- The text 'networkidle' (the page-load wait strategy indicator) was not visible on any reachable page during this session.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632947330941//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.742Z",
    "modified": "2026-02-21T00:15:47.475Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "85e5e521-8c58-48c8-a0e8-5db03d6f1668",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC015-Export both formats with selected classes shows COCO and YOLO outputs in the UI",
    "description": "Verifies the user can select COCO+YOLO and a class subset and sees both export outputs listed as completed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password fields and click the Sign In button to log in (input into index 20 and 21, then click index 22).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields (indexes 123 and 124) with test credentials and click the Sign In button (index 125) to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=COCO').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Sign In button not actionable; login form remains and 'Signing in...' state persists after submitting credentials\n- No redirect to post-login page (e.g., /home or /incidents) observed after multiple login attempts\n- Unable to access incident investigation flow; dataset build steps cannot be reached because authentication did not complete",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632864951995//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.749Z",
    "modified": "2026-02-21T00:14:25.065Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "096bb980-4294-4b2e-8f87-fe7f200897a2",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC016-Export both formats lists COCO JSON output path",
    "description": "Verifies the build results include a COCO annotation artifact entry referencing coco.json.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click 'Sign In' (use example@gmail.com and password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with example@gmail.com / password123 and click 'Sign In' to attempt authentication again.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=output/annotations/coco.json').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login did not complete after two attempts; the page remains on /login instead of redirecting to /home.\n- 'Signing in...' indicator appeared during attempts but no successful authentication or redirect occurred.\n- Authenticated pages (e.g., Build Dataset / New Build) could not be reached because the user remains unauthenticated.\n- Email and Password input fields and the Sign In button are still visible, indicating the app is still on the login screen.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632869517705//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.757Z",
    "modified": "2026-02-21T00:14:29.631Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "9656e75b-cf25-4b88-af04-e36182ad03a9",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC017-Export both formats lists YOLO output folder or files",
    "description": "Verifies the build results include a YOLO artifact entry referencing the yolo output location (folder or .txt outputs).",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with example@gmail.com (use test creds) as the first step of login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with test credentials and click the Sign In button to attempt login (input index 90 -> example@gmail.com, input index 94 -> password123, click index 98).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email (index 190) with 'example@gmail.com', fill the Password (index 191) with 'password123', then click the Sign In button (index 192) to submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=output/annotations/yolo').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed: the application remained on the login page after multiple submission attempts.\n- Sign In button not present as a clickable interactive element on the page, preventing reliable form submission.\n- Could not access authenticated pages (e.g., /home, incidents) required to reach Build Dataset / New Build views.\n- Build Dataset / New Build CTA and build results could not be reached or verified because authentication did not complete.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632880928031//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.763Z",
    "modified": "2026-02-21T00:14:41.052Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "cee55864-4034-4aab-a449-18c8e351d509",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC018-Selecting a class taxonomy subset shows the chosen classes in the export configuration summary",
    "description": "Verifies the UI reflects the chosen class list (button, link, input, checkbox, image_icon) before running export.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Input email into the email field (index 36) with example@gmail.com\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields (indexes 158 and 159) with test credentials and click the Sign In button (index 160) to attempt login again.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=button,link,input,checkbox,image_icon').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login did not complete - application remained on the login page (http://localhost:3000/login) after submitting credentials.\n- Signing-in state observed but no redirect to the post-login page (/home) occurred.\n- Build Dataset / New Build call-to-action not accessible because the user is not authenticated.\n- Classes input or UI for entering included classes could not be located; unable to verify 'button,link,input,checkbox,image_icon' is visible.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632844896434//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.770Z",
    "modified": "2026-02-21T00:14:05.014Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "0e305461-0016-493f-a294-9230e900751e",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC019-Export both formats with class subset completes successfully",
    "description": "Verifies a build configured for both exports and a specific class subset reaches a visible completed/success state.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter credentials into the login form and click Sign In to authenticate (fill email, fill password, click Sign In).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click Sign In to authenticate (use example@gmail.com / password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=Completed').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Authentication did not complete: the login page (email input index 193, password input index 194) remained visible after two sign-in attempts.\n- /home or /incidents pages were not reached due to failed authentication, preventing access to the Build Dataset flow.\n- Build/run steps could not be executed because the user is not authenticated and further identical login attempts are disallowed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632845108331//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.777Z",
    "modified": "2026-02-21T00:14:05.259Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "47082c02-850d-4713-a012-adddc90bb5e4",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC020-Unsupported export format shows a clear validation error and does not start export",
    "description": "Verifies entering an unknown export format triggers an 'unsupported export format' error message and prevents running.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type example@gmail.com into the Email field, type password123 into the Password field, then click Sign In.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password inputs again (clear any existing text) and click the Sign In button to submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields (clear existing text), then click the Sign In button to submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=unsupported export format').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login did not complete: application remained on the login page after two sign-in submissions.\n- Authentication did not reach the authenticated '/home' area; URL did not change to contain '/home'.\n- Build Dataset / New Build CTA could not be tested because user authentication was not established.\n- Sign In control became non-interactive or remained in a 'Signing in...' state, preventing progression to the next steps.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/177163291501813//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.783Z",
    "modified": "2026-02-21T00:15:15.154Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "2086b922-8217-4a3a-abc2-4fa74a119a29",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC021-Unsupported export format attempt exits the run flow (no outputs shown)",
    "description": "Verifies that after an unsupported export format error, no COCO/YOLO output artifacts are displayed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click 'Sign In' to log in (use example@gmail.com / password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click 'Sign In' to log in, then wait for the app to redirect (verify URL contains '/home').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Final assertion: verify that the unsupported export artifact path is not present in the current page content\n        frame = context.pages[-1]\n        content = await frame.content()\n        assert \"output/annotations/coco.json\" not in content, \"Unexpected artifact 'output/annotations/coco.json' is visible on the page (or feature missing detection failed).\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771633426687439//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.790Z",
    "modified": "2026-02-21T00:23:46.810Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "837abf4e-909a-4e96-abbc-2e58872e68ee",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC022-Classes field rejects invalid/empty taxonomy input",
    "description": "Verifies the UI validates the classes input and shows an error when the field is empty or invalid.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click the Sign In button (use input indexes 20 and 21, then click index 22).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 92) with 'example@gmail.com', fill the password (index 96) with 'password123', then click the Sign In button (index 100).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 193) and password (index 194), then click the Sign In button (index 195).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to navigate by clicking the AIDog header link (index 224) to refresh/navigate away from the stalled 'Signing in...' state and allow the app to re-render.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div[1]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email (index 291) with 'example@gmail.com', fill the password (index 292) with 'password123', then click the Sign In button (index 293).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/home' in frame.url\n        await expect(frame.locator('text=classes').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed - application remains on the login page and is stuck in a 'Signing in...' state after multiple attempts.\n- Sign In button not actionable or session not established after 4 authentication attempts using the provided test credentials.\n- Post-login URL (/home) and post-login UI (Build Dataset / New Build) are not present, preventing navigation to the feature under test.\n- Classes input validation could not be tested because the application could not be reached beyond the login screen.\n- Interactive elements required for the next steps (Build Dataset/New Build, Classes field) are not available on the current page.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632939411637//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.796Z",
    "modified": "2026-02-21T00:15:40.289Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "8d657da4-0c9f-4155-81ad-592eb4a011d7",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC023-Signup page loads and role selection is visible",
    "description": "Verifies the signup page can be opened and the role selection control is present.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign up' link (interactive element index 88) to open the signup page so assertions can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate explicitly to http://localhost:3000/signup using the required navigate action so the signup page can be inspected and assertions executed. ASSERTION: Navigation to /signup is required by test step and must use the navigate action.\n        await page.goto(\"http://localhost:3000/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Sign up').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[normalize-space(.)=\"Email\"]').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[normalize-space(.)=\"Password\"]').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[normalize-space(.)=\"Confirm password\"]').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[normalize-space(.)=\"Role\"]').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632796642663//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.803Z",
    "modified": "2026-02-21T00:13:16.754Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "478de95b-1035-4546-ae0a-52e0097fe8f0",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC024-Landing page surfaces legal/robots guidance in product messaging",
    "description": "Verifies the landing page contains visible guidance or warning text about crawling permissions and robots.txt behavior.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/ (home) and then check the landing page content for visible text containing 'robots.txt', 'permission', and 'crawl'.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Verify landing page contains guidance about crawling permissions and robots.txt behavior\n        xpaths = [\n            '/html/body/div/nav/div/a[1]',\n            '/html/body/div/nav/div/a[2]',\n            '/html/body/div/section[1]/div[3]/a[1]',\n            '/html/body/div/section[1]/div[3]/svg',\n            '/html/body/div/section[1]/div[3]/a[2]',\n            '/html/body/div/section[2]/div[2]/div/div[1]/div[1]',\n            '/html/body/div/section[2]/div[2]/div/div[2]/div[1]',\n            '/html/body/div/section[2]/div[2]/div/div[3]/div[1]',\n            '/html/body/div/section[3]/div/a',\n        ]\n        available_texts = {}\n        for xp in xpaths:\n            locator = frame.locator(f\"xpath={xp}\")\n            count = await locator.count()\n            if count:\n                try:\n                    text = await locator.inner_text()\n                except Exception:\n                    text = ''\n            else:\n                text = ''\n            available_texts[xp] = text\n        \n        missing = []\n        for term in ['robots.txt', 'permission', 'crawl']:\n            found = any((t or '').lower().find(term.lower()) != -1 for t in available_texts.values())\n            if not found:\n                missing.append(term)\n        \n        if missing:\n            raise AssertionError(f\"Landing page missing expected guidance about crawling permissions/robots.txt: could not find text(s): {', '.join(missing)}. Available elements and their texts: {available_texts}\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632830220424//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.810Z",
    "modified": "2026-02-21T00:13:50.333Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "aefc3e99-1b7e-49c3-8cde-7403d9eaa16d",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC025-Warning about default not respecting robots.txt is visible to users",
    "description": "Verifies users can find a warning that robots respect is disabled by default and they must ensure permission to crawl.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'AIDog' link (index 76) to go to the site root (/) so the page can be checked for the required warning texts.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to / (http://localhost:3000/) as the step explicitly requests, then check the page for the three required warning texts.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=respect-robots').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=false by default').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=ensure you have permission').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Required warning text 'respect-robots' not found on homepage at http://localhost:3000/.\n- Required warning text 'false by default' not found on homepage at http://localhost:3000/.\n- Required warning text 'ensure you have permission' not found on homepage at http://localhost:3000/.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632878176564//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.816Z",
    "modified": "2026-02-21T00:14:38.333Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "08c37828-99de-40f9-840f-bf937bc40675",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC026-Robots respect option is documented as an explicit opt-in",
    "description": "Verifies the UI copy communicates that respecting robots.txt is an explicit option/flag rather than the default.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/ (root) so the page can be inspected for the texts '--respect-robots' and 'option'\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=--respect-robots').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=option').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- '--respect-robots' UI copy not found on the root or login pages after multiple searches, indicating the feature/copy is missing or not publicly visible.\n- 'option' keyword not found on the root or login pages in the context of robots.txt, so there is no visible indication that respecting robots.txt is presented as an explicit option/flag.\n- Incidents flow could not be inspected for this UI copy because navigation to /incidents redirected to /login, preventing verification inside the authenticated incident investigation screens.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632816350594//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.823Z",
    "modified": "2026-02-21T00:13:36.517Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "d2108176-4370-48ea-a46d-5fd8ea6e7004",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC027-Legal guidance is accessible without authentication",
    "description": "Verifies legal/robots guidance is visible on a public route without requiring login.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the site root '/' (http://localhost:3000/) as the test step requires an explicit navigate to '/'\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=robots.txt').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=ensure').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- 'robots.txt' not found on the public site root page (legal/robots guidance not visible).\n- 'ensure' text not found on the public site root page (expected legal/guidance text missing).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632783834034//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.829Z",
    "modified": "2026-02-21T00:13:03.979Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "51fe54af-b22c-44ce-af7f-ad8913910089",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC028-Login page does not block access to legal/robots guidance discovery",
    "description": "Verifies a user can reach the login page and still locate references to safe crawling expectations via visible text or links back to the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Email').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Password').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632756887925//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.835Z",
    "modified": "2026-02-21T00:12:37.042Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "4125535f-67e5-447e-8714-f88bfc21e5d1",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC029-Signup page is accessible and does not imply robots respect is automatic",
    "description": "Verifies signup is reachable and does not present any misleading claim that robots.txt will always be respected by default.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign up' link (element index 66) to open the signup page so the signup content can be inspected for any misleading claim about robots.txt.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to http://localhost:3000/signup (explicit navigate step) to load the signup page so its content can be inspected for any misleading robots.txt claim.\n        await page.goto(\"http://localhost:3000/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Signup').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[contains(normalize-space(.), \"Email\")]').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('xpath=//label[contains(normalize-space(.), \"Password\")]').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632822558647//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.841Z",
    "modified": "2026-02-21T00:13:42.670Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "7ef8e694-afc3-4ac3-98df-b7d61c828436",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC030-Legal/robots guidance remains visible after scrolling through landing content",
    "description": "Verifies the user can scroll and still find robots/legal guidance in visible sections (e.g., how-it-works or FAQ).",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the site root '/' (http://localhost:3000/) so the page can be scrolled and checked for 'How it works' or FAQ content.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'See How It Works' link (index 143) to reveal/scroll to the How It Works section so the page can be checked for 'robots.txt' and 'permission' text.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/section[1]/div[3]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Verify the \"How it Works\" section is visible after clicking \"See How It Works\"\n        how_elem = frame.locator('xpath=/html/body/div[1]/section[2]/div[2]/div/div[1]/div[1]')\n        await how_elem.wait_for(state='visible', timeout=5000)\n        assert await how_elem.is_visible(), 'How it Works section not visible after clicking See How It Works'\n        \n        # The required texts \"robots.txt\" and \"permission\" are not present in the provided available elements list.\n        # Report the missing feature/content and mark the task done.\n        raise AssertionError('Missing expected guidance texts on page: \"robots.txt\" and \"permission\". Feature/content not found.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/17716328064656//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.847Z",
    "modified": "2026-02-21T00:13:26.581Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "48ce28b0-1a5f-4e8c-8278-3f724d877306",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC031-Login and reach authenticated Home dashboard",
    "description": "Verifies a user can log in with valid credentials and land on the authenticated Home page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=3000)\n        assert '/home' in frame.url\n        await expect(frame.locator('text=Service health').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632754791788//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.854Z",
    "modified": "2026-02-21T00:12:34.935Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "8005d009-b1df-488c-8072-17e19b09317a",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC032-Navigate to Incidents list from Home",
    "description": "Verifies an authenticated user can open the Incidents list page from the Home dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click 'Sign In' to authenticate (use example@gmail.com / password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Email and Password fields with example@gmail.com / password123 and click the 'Sign In' button to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        assert '/incidents' in frame.url\n        await expect(frame.locator('text=Incidents').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Login failed - page still shows the login form and URL path is '/login' after two sign-in attempts.\n- Sign-in action did not complete - the sign-in button remains in state 'Signing in...' indicating the authentication process is stuck or blocked.\n- Incidents navigation could not be accessed - the Incidents list was not reached because the user remained unauthenticated.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632853043791//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.860Z",
    "modified": "2026-02-21T00:14:13.158Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "1a88d06d-24cd-4546-b5f6-15d880503d1a",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC033-Incidents list shows severity badges and timestamps",
    "description": "Verifies the Incidents list UI renders key incident summary information for quick scanning.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password inputs and click the 'Sign In' button to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=/html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sign In' button again to attempt authentication, then wait for the app to complete login and redirect.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Severity').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Timestamp').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "TEST FAILURE\n\nASSERTIONS:\n- Sign-in did not complete: after two 'Sign In' attempts the login form remains visible and the application did not redirect to the Incidents list or dashboard.\n- Access to the Incidents page could not be verified because authentication failed and main navigation to Incidents was not reachable.\n- No explicit authentication success or informative error message was presented after submitting the login form.\n- Test credentials were entered into the email and password fields (email='example@gmail.com') but were not accepted.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/177163284701402//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.868Z",
    "modified": "2026-02-21T00:14:07.183Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "0ffacb91-0a62-4bcd-926e-3e26a253027f",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC034-Invalid password shows an error message",
    "description": "Verifies the login page rejects invalid credentials and displays a visible error state.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Login').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Invalid').first).to_be_visible(timeout=3000)\n        assert '/login' in frame.url\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632763964903//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.874Z",
    "modified": "2026-02-21T00:12:44.083Z"
  },
  {
    "projectId": "6764144e-b8d9-493e-aefa-508a507138cf",
    "testId": "2e4afe02-06bc-4fae-bf23-d8224d3fad19",
    "userId": "84e81498-d091-7043-8d20-a0f6539edc79",
    "title": "TC035-Signup page renders required fields including role selection",
    "description": "Verifies the signup form is accessible and shows all expected inputs for account creation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000/incidents\n        await page.goto(\"http://localhost:3000/incidents\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Sign up' link (element index 66) to open the signup form so the required fields can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=/html/body/div/div/div/form/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /signup (http://localhost:3000/signup) to load the signup form so the required inputs can be verified.\n        await page.goto(\"http://localhost:3000/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Sign up').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Email').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Password').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Confirm password').first).to_be_visible(timeout=3000)\n        await expect(frame.locator('text=Role').first).to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e81498-d091-7043-8d20-a0f6539edc79/1771632803343824//tmp/test_task/result.webm",
    "created": "2026-02-21T00:11:16.880Z",
    "modified": "2026-02-21T00:13:23.459Z"
  }
]
